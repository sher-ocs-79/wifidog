<?php

/* vim: set expandtab tabstop=2 shiftwidth=2 softtabstop=2: */

// +-------------------------------------------------------------------+
// | WiFiDog Authentication Server                                     |
// | =============================                                     |
// |                                                                   |
// | The WiFiDog Authentication Server is part of the WiFiDog captive  |
// | portal suite.                                                     |
// +-------------------------------------------------------------------+
// | PHP version 5 required.                                           |
// +-------------------------------------------------------------------+
// | Homepage:     http://www.wifidog.org/                             |
// | Source Forge: http://sourceforge.net/projects/wifidog/            |
// +-------------------------------------------------------------------+
// | This program is free software; you can redistribute it and/or     |
// | modify it under the terms of the GNU General Public License as    |
// | published by the Free Software Foundation; either version 2 of    |
// | the License, or (at your option) any later version.               |
// |                                                                   |
// | This program is distributed in the hope that it will be useful,   |
// | but WITHOUT ANY WARRANTY; without even the implied warranty of    |
// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
// | GNU General Public License for more details.                      |
// |                                                                   |
// | You should have received a copy of the GNU General Public License |
// | along with this program; if not, contact:                         |
// |                                                                   |
// | Free Software Foundation           Voice:  +1-617-542-5942        |
// | 59 Temple Place - Suite 330        Fax:    +1-617-542-2652        |
// | Boston, MA  02111-1307,  USA       gnu@gnu.org                    |
// |                                                                   |
// +-------------------------------------------------------------------+

/**
 * EventLogging: a message logging class.
 *
 * Logging messages of various levels, from debug to critical, from
 * php or generated by the program, can be formatted and directed to
 * a file, be displayed on the html page, as comments or as a table,
 * or be held and collected for display later in a special <div>
 * block.
 *
 * Logging messages once accepted at intake will be processed by all
 * active output channels.  ie, the message will be written by all
 * the output channels, not just one.
 *
 * Output channels currently supported:
 *
 * FileChannel - appends messages to a file
 * NullChannel - discards all messages
 * PrintChannel - writes messages via "echo" or "print"
 * ArrayChannel - accumulates messages in an array.  It's like
 *   PrintChannel, except that the hold flag is always on, and that
 *   the only way to get messages out is to call the flush method.
 *   PrintChannel will print any held messages at destruct time, but
 *   ArrayChannel's destruct will discard any held messages.
 *
 * Output formats currently supported:
 * SyslogFormatter - like syslog, with a datestamp prefixed
 * HTMLTableFormatter - as table row elements
 * HTMLCommentsFormatter - as html comments
 *
 * Collection of logging messages can be turned off temporarily,
 * either by using the standard php '@' prefix, or by using the
 * off() and on() methods, and their static equivalents,
 * EventLogging::stOn() and EventLogging::stOff().
 *
 * Debugging of specific methods, functions, or files is supported
 * by allowing messages from such contexts to be redirected to a
 * unique channel, or the message can be catapulted to a different
 * importance level, like critical, to make sure it gets written by
 * one of the output channels.
 *
 * By using the addContextFilter method you can specify special
 * treatment for messages based on the method, function or file the
 * message came from.  debug_backtrace() is used to see if the context
 * is on the stack.  If it is, then the special treatment is applied.
 *
 * @todo Extensible to a more general transactional processing system,
 * useful in a context where the work to be done should have BEGIN
 * WORK and COMMIT/ROLLBACK logic, but either the database in use
 * does not support it, or the work being done is multiply facited,
 * involving non-database elements that should be rolled back too.
 *
 *
 * usage: at the start in mainline, to setup the logging environment
 *
 * $log = EventLogging::stGlobal($_ENV['DEBUG']);
 *
 *  Examples of strings to pass stGlobal:
 *   "Class::Method(critical)" - matches messages from Class::Method, makes them critical
 *   "Class::Method(off)" - matches messages from Class::Method, dumps them
 *   "strict~/var:\sDeprecated/(off)" - matches message text with "strict" level, dumps them
 *   "Function(critical) /this/path/file.php(debug)" - matches messages from Function, makes them critical,
 *       and matches any messages by any code in /this/path/file.php, makes them debug level
 * Separate multiple entries with spaces, not commas.
 *
 * Add output channels, globally.  All messages will pass to these channels, unless
 * a function/method/file override comes into play.
 *
 * $log->addChannel(new FileChannel("logg.txt", new SyslogFormatter(), 'error,notice'));
 * $log->addChannel(new PrintChannel(new HTMLCommentsFormatter(), '=debug'));
 * $log->addChannel(new ArrayChannel(new HTMLFormatter(), 'warning,notice'));
 *
 * Or, start up logging all at once:
 * EventLogging::SetupErrorHandling('notice~/Constant.+already\sdefined/(off)',
 *      new PrintChannel(new HTMLCommentsFormatter(), '=debug'),
 *     new PrintChannel(new HTMLFormatter(), 'warning,notice'));
 *
 *
 * automatic intake/capture of system messages and exceptions
 * elLogMessage("message", level)
 * elLogError("message")
 * elLogWarning("message")
 * elLogNotice("message")
 * elLogInfo("message")
 * elLogDebug("message")
 *
 * or $log->message("message", EventObject::EVO_USER_WARNING)
 * or EventLogging::stMessage("message", EventObject::EVO_USER_WARNING)
 *
 * or $log->error("message")
 * or $log->warning("message")
 * or $log->notice("message")
 * or $log->info("message")
 * or $log->debug("message")
 *
 * broadcastEvent(new Event( ... ))
 * elLogEvent()
 *
 * access to the logging stuff is easy, global
 * $log = EventLogging::getGlobal();
 *
 * Howto silence logging:
 *   $log->off();
 *   or EventLogging::stOff();
 *   or put "@" in front of the expression (standard php trick)
 *
 *   then "blah blah blah stuff that emits annoying errors and won't shut up"
 *
 *   $log->on();
 *   or EventLogging::stOn();
 *
 * Howto zero in on buggy routines, or in development
 *
 * Context filters are supposed to be applied at the global level,
 * during the initialization phase.  They allow file, class or
 * function overrides on logging behaviour.  Using context filters
 * you can put all your special logging stuff in one place, rather
 * than tracking down the subroutine you want to tweak and editing
 * it.
 *
 * Note that the effectiveLevel controls how the log message passes
 * through the channels, in that the channels typically screen out
 * messages based on their level.
 *
 * The formatting of the message for display is taken to be a
 * separate thing, so that you can override the effectiveLevel to
 * critical so that the message will be printed by most channels,
 * while not changing the printed message, so that it still says
 * "debug" or whatever.
 *
 * EventLogging::stAddContextFilter(
 *     array('class' => 'ClassName',
 *           'function' => 'MethodName',
 *           'effectiveLevel'=>'critical'));
 *
 * EventLogging::stAddContextFilter(
 *     array('function' => 'FunctionName',
 *           'redirect'=>new PrintChannel(new HTMLCommentsFormatter(), 'debug')));
 *
 * EventLogging::stAddContextFilter(
 *     array('file' => 'FileName',
 *           'redirect'=>new NullChannel('debug', 'blockPercolation')));
 *
 * This will do the same sort of thing as a context filter, but you
 * have to put it in the method or function:
 *
 * $log = new EventLogging(); // knows it's a context change, context removed when $log __destruct is called
 * $log->setEffectiveLevel('critical');
 *
 * Printing out log messages where you want them, in the style you want
 * EventLogging::stFlushChannels()
 * returns the number of messages flushed out.
 *
 * Finally,
 * elBomb("message")
 * since die("message") when caught by a handler gives no stack backtrace, use elBomb(..) instead of die(..).
 * elBomb will give a stack trace.
 *
 * A complete example:
 *
 * require_once 'classes/EventLogging.php';
 *
 * class myHTMLTableFormatter extends EventFormatter {
 *   public function formatMessage($pCSSClass, $pMessageType, $pMessage, $pFilename, $pLinenum) {
 *     $pCSSClass = empty($pCSSClass) ? '' : "class='log_$pCSSClass'";
 *     $string = "<tr>" .
 *            "<td $pCSSClass>$pMessageType</td><td $pCSSClass>$pMessage</td>" .
 *            (!empty($pFilename) ? "<td $pCSSClass>$pFilename</td>" .
 *             (!empty($pLinenum) ? "<td $pCSSClass>$pLinenum</td>" : "") : "") .
 *             "</tr>\n";
 *
 *     return $string;
 *   }
 * }
 *
 * EventLogging::SetupErrorHandling('notice~/Constant.+already\sdefined/(off)',
 *      array( 'status' => new ArrayChannel(new myHTMLTableFormatter(), 'all,!debug', null, true),
 *             'debug' => new PrintChannel(new HTMLCommentsFormatter(), '=debug', null, false)));
 * ....
 * ... @fopen(...) ...
 * elLogError("failed to open file");
 * ....
 *
 *  print "<div id='status'>\n";
 * print "<table>\n";
 * print "<tr><th>Type</th><th>Message</th><th>File</th><th>Line</th></tr>\n";
 * if (!EventLogging::stFlushChannels('status'))
 *   print "<tr><td colspan='4'>No Messages</td></tr>\n";
 * print "</table>\n";
 * print "</div>\n";
 *
 *
 * @package    WiFiDogAuthServer
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 * @version    Subversion $Id$
 * @link       http://www.wifidog.org/
 */

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class EventLogging {
  private static $globalTracker;

  private $observers; // with layout supervisors (formatters), these are a tee to write to files/sinks

  private $contextFilters;

  private $stackPtrMoreGlobal;
  private $stackPtrMoreSpecific;

  private $stackPtrMostSpecific;

  private $defaultObserver;

  private $on;
  private $debug;
  private $effectiveLevel;

  private function __construct() {
    $this->observers = array();
    $this->contextFilters = array();

    $this->stackPtrMostSpecific = null;

    $this->stackPtrMoreSpecific = null;

    $this->stackPtrMoreGlobal = empty(self::$globalTracker) ? null : $this->enchain();
  }

  function __destruct() {
    $this->unchain();
  }

  private function enchain() {
    $end = self::$globalTracker->stackPtrMostSpecific;
    $this->stackPtrMoreGlobal = $end;
    $this->stackPtrMoreSpecific = null;

    $end->stackPtrMoreSpecific = $this;
    self::$globalTracker->stackPtrMostSpecific = $this;
  }

  private function unchain() {
    $before = $this->stackPtrMoreGlobal;
    $after = $this->stackPtrMoreSpecific;

    if (!empty($before)) $before->stackPtrMoreSpecific = $after;
    if (!empty($after)) $after->stackPtrMoreGlobal = $before;

    $this->stackPtrMoreGlobal = $this->stackPtrMoreSpecific = null;
    if (empty($after) && !empty(self::$globalTracker)) self::$globalTracker->stackPtrMostSpecific = $before;
  }

  public static function SetupErrorHandling($pString=null) {
    if (empty(self::$globalTracker)) {
      $obj = new self();
      self::$globalTracker = $obj;
      $obj->stackPtrMostspecific = $obj;

      //$obj->on = true;

      if (!empty($pString)) $obj->quickContextFilters($pString);

      //$what = array();
      if (($n = func_num_args()) > 1) {
				// process channels
				for ($i=1; $i<$n; $i++) {
					$channel = func_get_arg($i);
					if (!is_array($channel)) {
						$obj->addChannel($channel);
						//$what[] = $i;
					}
					else {
						foreach ($channel as $name=>$channel2) {
							$obj->addChannel($channel2, $name);
							//$what[] = $name;
						}
					}
				}
      }

      self::CaptureAll();

      //print "<!-- $n ".implode(", ", $what)."\n";
      //print_r($obj);
      //print "\n-->\n";
    }

    return self::$globalTracker;
  }

  public static function stGlobal($pString=null) {
    return self::SetupErrorHandling($pString);
  }

  //***********************************************************************************

  public function broadcastEvent($pEvent, $pOn=null, $pDebug=null, $pEffectiveImportance=null) {
    if (isset($this->on)) $pOn = $this->on;
    if (isset($this->debug)) $pDebug = $this->debug;
    if (isset($this->effectiveLevel)) $pEffectiveImportance = $this->effectiveLevel;

    $myBlockPercolation = false;

    $myCountSinks = 0;

    $myWatchpoint = null;
    $myForceOnEvent = null;
    if (!empty($this->contextFilters) && count($this->contextFilters)>0) {
      // logging is supposed to be quick.  this is slow, but is most useful for debugging.
      $myCountSinks++;

      $myWatchpoint = $this->filterContext($pEvent); // returns true or false or a channel object

      $myForceOnEvent = $pEvent->getOnFlag();
      if (isset($myForceOnEvent)) $pOn = $myForceOnEvent;

      if (is_object($myWatchpoint))
				if ($myWatchpoint->receiveEvent($pEvent)) {
					// since this is a specific match at this level
					// allow this section here the ability to override the more general stuff
					// ie, if this specific match results in a "don't let any other channels run" flag, do it immediately
					$myBlockPercolation = true;
					return $myBlockPercolation;
				}
    }

    if (!empty($this->stackPtrMoreSpecific)) {
      $myCountSinks++;
      $myBlockPercolation = $this->stackPtrMoreSpecific->broadcastEvent($pEvent, $pOn, $pDebug, $pEffectiveImportance);
    }

    if ((error_reporting()==0 && empty($pDebug)) || $myBlockPercolation)
      return $myBlockPercolation;

    if (!isset($pOn) || $pOn) {
      $myWatchers =& $this->observers;

      if (count($myWatchers)==0 && $this===self::$globalTracker && $myCountSinks==0) {
				// the out-of-the box behaviour of EventLogging should be the same as PHP
				if (empty($this->defaultObserver))
					$this->defaultObserver = new PrintChannel(new HTMLFormatter(), 'error,notice');

				if (!empty($this->defaultObserver))
					$myWatchers = array($this->defaultObserver);
      }

      foreach ($myWatchers as $watcher) {
				$myCountSinks++;
				if ($watcher->receiveEvent($pEvent, $pEffectiveImportance))
					$myBlockPercolation = true;;
      }
    }

    return $myBlockPercolation;
  }

  public static function stBroadcastEvent($event) {
    if (empty(self::$globalTracker)) return null;
    $beginning = self::$globalTracker;
    $beginning->broadcastEvent($event, $beginning->getOn(), $beginning->getDebugFlag());
  }

  public function flushChannels($pName=null) {
    $myMessagesFlushedCounter = 0;
    if (!empty($this->stackPtrMoreSpecific))
      $myMessagesFlushedCounter += $this->stackPtrMoreSpecific->flushChannels($pName);

    if (!empty($this->defaultObserver) && (empty($pName) || $pName==='DEFAULT'))
      $myMessagesFlushedCounter += $this->defaultObserver->flushEventQueue();

    if (!empty($pName)) {
      $watcher = $this->getChannel($pName);
      if (!empty($watcher)) $watcher->flushEventQueue();
    }
    elseif (!empty($this->observers)) {
			foreach ($this->observers as $watcher)
				$myMessagesFlushedCounter += $watcher->flushEventQueue();
    }

    return $myMessagesFlushedCounter;
  }

  public static function stFlushChannels($pName=null) {
    if (empty(self::$globalTracker)) return null;
    $beginning = self::$globalTracker;
    return $beginning->flushChannels($pName);
  }

  public static function stOn() {
    $obj = self::$globalTracker;
    if (empty($obj)) return null;

    $sav = isset($obj->on) ? $obj->on : null;
    $obj->on = true;
    return $sav;
  }

  public static function stOff() {
    if (empty(self::$globalTracker)) return null;

    $obj = self::$globalTracker;

    $sav = isset($obj->on) ? $obj->on : null;
    $obj->on = false;
    return $sav;
  }

  public static function stRestore($flag) {
    if (empty(self::$globalTracker)) return null;

    self::$globalTracker->on = $flag;
  }

  public function on() {
    $sav = isset($this->on) ? $this->on : null;
    $this->on = true;
    return $sav;
  }
  public function off() {
    $sav = isset($this->on) ? $this->on : null;
    $this->on = false;
    return $sav;
  }
  public function restore($flag) {
    $this->on = $flag;
  }
  public function getOn() {
    return isset($this->on) ? $this->on : null;
  }
  public function isOn() {
    if (error_reporting()==0 && empty($this->debug)) return false;
    return isset($this->on) ? $this->on : (isset(self::$globalTracker->on) ? self::$globalTracker->on : false);
  }
  public function isOff() {
    return $this->isOn() ? false : true;
  }

  public function getDebugFlag() {
    return isset($this->debug) ? $this->debug : null;
  }
  public function setDebugFlag($flag) {
    $sav = $this->debug;
    $this->debug = $flag ? true : false;
    return $sav;
  }
  public function setEffectiveLevel($level) {
    $sav = $this->effectiveLevel;
    $this->effectiveLevel = $level;
    return $sav;
  }
  public function getEffectiveLevel() {
    return $this->effectiveLevel;
  }

  public static function stMessage($pMessage, $pErrorType=EventObject::EVO_USER_NOTICE) {
    global $elDefaultLogging;

    if (empty(self::$globalTracker)) {
      if (empty($elDefaultLogging))
				$elDefaultLogging = new PrintChannel(new HTMLFormatter(), 'warning,notice');

      $elDefaultLogging->receiveEvent(new EventObject($pMessage, $pErrorType));
    }
    else
      self::stBroadcastEvent(new EventObject($pMessage, $pErrorType));
  }

  public function message($pMessage, $pErrorType=EventObject::EVO_USER_NOTICE) {
    $this->broadcastEvent(new EventObject($pMessage, $pErrorType));
  }
  public function error($pMessage) {
    $this->broadcastEvent(new EventObject($pMessage, EventObject::EVO_USER_ERROR));
  }
  public function warning($pMessage) {
    $this->broadcastEvent(new EventObject($pMessage, EventObject::EVO_USER_WARNING));
  }
  public function notice($pMessage) {
    $this->broadcastEvent(new EventObject($pMessage, EventObject::EVO_USER_NOTICE));
  }
  public function info($pMessage) {
    $this->broadcastEvent(new EventObject($pMessage, EventObject::EVO_INFO));
  }
  public function debug($pMessage) {
    $this->broadcastEvent(new EventObject($pMessage, EventObject::EVO_DEBUG));
  }

  //***********************************************************************************

  public static function ErrorHandler($pSystemErrorType, $pMessage, $pFilename, $pLinenum, $pVars) {
    $myErrorReportingOn = error_reporting(); // is 0 if '@' prepends statement

    if ($myErrorReportingOn || (isset(self::$globalTracker) && self::$globalTracker->debug)) {
      $eo = new EventObject($pMessage, EventObject::ErrorType($pSystemErrorType));
      $eo->setFilename($pFilename);
      $eo->setLinenum($pLinenum);

      self::stBroadcastEvent($eo);
    }

    // if ($pSystemErrorType == E_ERROR) die($pMessage); // i don't think php passes E_ERROR to a user error handler
    // if ($pSystemErrorType == E_USER_ERROR) die($pMessage); // die if E_USER_ERROR
  }

  public static function ExceptionHandler($pException) {
    $eo = new EventObject($pException->getMessage());
    $eo->setFilename($pException->getFile());
    $eo->setLinenum($pException->getLine());
    $t = $pException->getTrace();
    $eo->setContext($t);

    self::stBroadcastEvent($eo);
  }

  public static function DieHandler() {
    // is this normal program exit, or was there an error?
    $eo = new EventObject("die()", EventObject::EVO_ERROR);

    self::stBroadcastEvent($eo);
  }

  //***********************************************************************************

  public static function CaptureErrors() {
    error_reporting(E_ALL);
    return set_error_handler(array('EventLogging', 'ErrorHandler'));
  }

  public static function CaptureExceptions() {
    return set_exception_handler(array('EventLogging', 'ExceptionHandler'));
  }

  public static function CaptureDie() {
    register_shutdown_function(array('EventLogging', 'DieHandler'));
  }

  public static function CaptureAll() {
    self::CaptureExceptions();
    self::CaptureErrors();
    //self::CaptureDie();

    return true;
  }

  public function bomb($pMessage=null) {
    if (empty($pMessage))
      $pMessage = "Bomb()";

    $eo = new EventObject($pMessage, EventObject::EVO_ERROR);
    $this->broadcastEvent($eo);

    die($pMessage);
  }

  public static function stBomb($pMessage=null) {
    if (func_num_args() > 0) {
      // log $message
    }

    if (empty($pMessage))
      $pMessage = "Bomb()";

    $eo = new EventObject($pMessage, EventObject::EVO_ERROR);
    self::stBroadcastEvent($eo);

    die($pMessage);
  }

  public function addChannel($pObserver, $pName=null) {
    if (empty($pName)) $pName = count($this->observers);

    if ("$pName" == 'DEFAULT')
      $this->defaultObserver = $pObserver;
    else
      $this->observers[$pName] = $pObserver;

    return $pName;
  }
  public static function stAddChannel($pObserver) {
    self::$globalTracker->addChannel($pObserver);
  }

  public function getChannel($pName) {
    return $pName == 'DEFAULT' ? $this->defaultObserver : (empty($this->observers[$pName]) ? false : $this->observers[$pName]);
  }

  public function remChannel($pChannel) {
    if (!is_object($pChannel))
      $pName = $pChannel;
    else {
      foreach ($this->observers as $name => $observer) {
				if ($observer===$pChannel) {
					$pName = $name;
					break;
				}
      }
    }

    if (!empty($pName))
      if ($pName == 'DEFAULT')
				unset($this->defaultObserver);
      else
				unset($this->observers[$pName]);
  }

  public static function stAddContextFilter($options) {
    $context = array();

    if (!empty($options['file'])) {
      $context['file'] = $options['file'];
    }
    elseif (!empty($options['class'])) {
      $context['class'] = $options['class'];
      $context['function'] = $options['function'];
    }
    elseif (!empty($options['function'])) {
      $context['class'] = '';
      $context['function'] = $options['function'];
    }
    elseif (!empty($options['matchlevel'])) {
      $context['matchlevel'] = $options['matchlevel'];
      $context['matchpattern'] = $options['matchpattern'];
    }

    if (!empty($options['redirect'])) $context['redirect'] = $options['redirect'];
    if (!empty($options['effectiveLevel'])) $context['effectiveLevel'] = $options['effectiveLevel'];

    self::$globalTracker->contextFilters[] = $context;
  }

  public function filterContext(&$event) {
    $needle =& $event;
    $found = null;
    foreach ($this->contextFilters as $haystack) {
      $filename = $needle->getFilename();
      $context = $needle->getContext();
      if (!empty($haystack['matchlevel'])) {
				if ($haystack['matchlevel'] == $needle->getLayoutType()) {
					if (preg_match($haystack['matchpattern'], $needle->getMessage())) {
						$found = $haystack;
					}
				}

				// print "\n<!-- filterContext haystack $haystack[matchlevel], $haystack[matchpattern], $haystack[effectiveLevel] ". "'".$needle->getMessage()."' ".(empty($found) ? "NOT FOUND" : "FOUND"). " -->\n";
      }
      elseif (!empty($haystack['file'])) {
				if ($filename == $haystack['file']) {
					$found = $haystack;
				}
				else {
					foreach ($context as $backtrace) {
						if ($backtrace['file'] == $haystack['file']) {
							$found = $haystack;
							break;
						}
					}
				}
      }
      elseif (!empty($haystack['class'])) {
				foreach ($context as $backtrace) {
					if (!empty($backtrace['class']) && $backtrace['class'] == $haystack['class'] &&
							(empty($haystack['function']) || $backtrace['function'] == $haystack['function'])) {
						$found = $haystack;
						break;
					}
				}
      }
      elseif (!empty($haystack['function'])) {
				foreach ($context as $backtrace) {
					if (!empty($backtrace['function']) && $backtrace['function'] == $haystack['function']) {
						$found = $haystack;
						break;
					}
				}
      }

      if (!empty($found))
				break;
    }

    if (!empty($found)) {
      if (!empty($found['effectiveLevel'])) {
				if ($found['effectiveLevel'] == 'on')
					$needle->setOnFlag(true);
				elseif ($found['effectiveLevel'] == 'off')
					$needle->setOnFlag(false);
				else
					$needle->setImportance($found['effectiveLevel']);
      }

      if (!empty($found['redirect']))
				return $found['redirect'];

      return true;
    }

    return false;
  }

  //"Class::Method(critical)"
  //"Class::Method(off)"
  //"strict~/var:\sDeprecated/(off)"
  //"Function(critical) /this/path/file.php(debug)"
  public function quickContextFilters($pString) {
    if (empty($pString)) return 0;

    $myCounter = 0;
    $myList = preg_split('/\s+/', $pString, -1, PREG_SPLIT_NO_EMPTY);
    foreach ($myList as $myItem) {
      if (preg_match('/^([^()]+)\(([^()]+)\)$/', $myItem, $myMatches)) {
				$myContext = $myMatches[1];
				$myOverride = $myMatches[2];
				$filter = array();
				if (strpos($myContext, '::') !== false) {
					// class
					$tmp = explode('::', $myContext, 2);
					$filter['class'] = trim($tmp[0]);
					if (preg_match('/\S/', $tmp[1])) $filter['function'] = trim($tmp[1]);
					$filter['effectiveLevel'] = trim($myOverride);
				}
				elseif (strpos($myContext, '~') !== false) {
					// message match
					$tmp = explode('~', $myContext, 2);
					$filter['matchlevel'] = trim($tmp[0]);
					$filter['matchpattern'] = trim($tmp[1]);
					$filter['effectiveLevel'] = trim($myOverride);
				}
				elseif (strpos($myContext, '/') !== false) {
					// file
					$filter['file'] = trim($myContext);
					$filter['effectiveLevel'] = trim($myOverride);
				}
				else {
					// function
					$filter['function'] = trim($myContext);
					$filter['effectiveLevel'] = trim($myOverride);
				}

				if (EventObject::stClassifyErrorType($myOverride)) {
					EventLogging::stAddContextFilter($filter);
					$myCounter++;
				}
      }
    }

    return $myCounter;
  }
}

define('_EL_DEBUG', 'debug');
define('_EL_INFO', 'info');
define('_EL_CRITICAL', 'critical');

define('_EL_ERROR', 'error');	// can't be captured
define('_EL_WARNING', 'warning');
define('_EL_PARSE', 'parse');	// can't be captured
define('_EL_NOTICE', 'notice');
define('_EL_CORE_ERROR', 'core error'); // can't be captured
define('_EL_CORE_WARNING', 'core warning'); // can't be captured
define('_EL_COMPILE_ERROR', 'compile error'); // can't be captured
define('_EL_COMPILE_WARNING', 'compile warning'); // can't be captured
define('_EL_USER_ERROR', 'user error');
define('_EL_USER_WARNING', 'user warning');
define('_EL_USER_NOTICE', 'user notice');
define('_EL_STRICT', 'strict');

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class EventObject {
  private $message;
  private $layoutType;
  private $filterImportance;
  private $type;
  private $context;

  private $timestamp;

  private $exception;
  private $filename;
  private $linenum;
  private $code;

  private $taskLabel;
  private $actions;
  private $undoActions;
  private $onFlag;

  const EVO_DEBUG = _EL_DEBUG;
  const EVO_INFO = _EL_INFO;
  const EVO_CRITICAL = _EL_CRITICAL;

  const EVO_ERROR = _EL_ERROR;	// can't be captured
  const EVO_WARNING = _EL_WARNING;
  const EVO_PARSE = _EL_PARSE;	// can't be captured
  const EVO_NOTICE = _EL_NOTICE;
  const EVO_CORE_ERROR = _EL_CORE_ERROR; // can't be captured
  const EVO_CORE_WARNING = _EL_CORE_WARNING; // can't be captured
  const EVO_COMPILE_ERROR = _EL_COMPILE_ERROR; // can't be captured
  const EVO_COMPILE_WARNING = _EL_COMPILE_WARNING; // can't be captured
  const EVO_USER_ERROR = _EL_USER_ERROR;
  const EVO_USER_WARNING = _EL_USER_WARNING;
  const EVO_USER_NOTICE = _EL_USER_NOTICE;
  const EVO_STRICT = _EL_STRICT;

  public function __construct($pMessage = null, $pImportance = self::EVO_USER_NOTICE) {
    $this->message = $pMessage;
    $this->layoutType = $pImportance;
    $this->filterImportance = $pImportance;
    $this->type = 'log';
    $this->taskLabel = 'global';	// 'log' types may be scoped to tasks
    $this->context = debug_backtrace(); // context for 'log' type is a stack backtrace array
    $this->actions = null;	// 'log' types have no action records
    $this->undoActions = null;	// 'log' types have no rollback records
    $this->timestamp = time();
    $this->onFlag = null;
  }

  public function getTimestamp() {
    return $this->timestamp;
  }

  public function setMessage(&$pMessage) {
    $sav = $this->message;
    $this->message = $pMessage;
    return $sav;
  }
  public function getMessage() {
    return $this->message;
  }

  public function setLayoutType(&$pLayoutType) {
    $sav = $this->layoutType;
    $this->layoutType = $pLayoutType;
    return $sav;
  }
  public function getLayoutType() {
    return $this->layoutType;
  }

  public function setImportance(&$pImportance) {
    $sav = $this->filterImportance;
    $this->filterImportance = $pImportance;
    return $sav;
  }
  public function getImportance() {
    return $this->filterImportance;
  }

  public function setException($pException) {
    $this->exception = $pException;
  }
  public function getException() {
    return $this->exception;
  }
  public function setFilename($pFilename) {
    $this->filename = $pFilename;
  }
  public function getFilename() {
    return $this->filename;
  }
  public function setLinenum($pLinenum) {
    $this->linenum = $pLinenum;
  }
  public function getLinenum() {
    return $this->linenum;
  }
  public function setCode($pCode) {
    $this->code = $pCode;
  }
  public function getCode() {
    return $this->code;
  }
  public function setOnFlag($pOnFlag) {
    $this->onFlag = $pOnFlag;
  }
  public function getOnFlag() {
    return $this->onFlag;
  }

  public function setType(&$pType) {
    $sav = $this->type;
    $this->type = $pType;
    return $sav;
  }
  public function getType() {
    return $this->type;
  }

  public function setContext(&$pContext) {
    $sav = $this->context;
    $this->context = $pContext;
    return $sav;
  }
  public function getContext() {
    return $this->context;
  }
  public function adjustContext($shifts=1) {
    array_splice($this->context,0,$shifts);
  }

  public static $ClassifyErrorTypes =
    array (
					 _EL_DEBUG           => 'debug',
					 _EL_INFO            => 'info',
					 _EL_CRITICAL        => 'critical',

					 _EL_ERROR           => 'error',
					 _EL_WARNING         => 'warning',
					 _EL_PARSE           => 'parse',
					 _EL_NOTICE          => 'notice',
					 _EL_CORE_ERROR      => 'error',
					 _EL_CORE_WARNING    => 'warning',
					 _EL_COMPILE_ERROR   => 'error',
					 _EL_COMPILE_WARNING => 'warning',
					 _EL_USER_ERROR      => 'error',
					 _EL_USER_WARNING    => 'warning',
					 _EL_USER_NOTICE     => 'notice',
					 _EL_STRICT          => 'notice',
					 'off'                     => 'off',
					 'on'                      => 'on',
					 'all'                     => 'all',
					 );

  public static $GroupErrorTypes =
    array (
					 'debug'    => array(_EL_DEBUG),
					 'info'     => array(_EL_INFO),
					 'critical' => array(_EL_CRITICAL),

					 'error'    => array(_EL_ERROR, _EL_CORE_ERROR, _EL_COMPILE_ERROR, _EL_USER_ERROR),
					 'warning'  => array(_EL_WARNING, _EL_CORE_WARNING, _EL_COMPILE_WARNING, _EL_USER_WARNING),
					 'notice'   => array(_EL_NOTICE, _EL_USER_NOTICE, _EL_STRICT),
					 'user'     => array(_EL_USER_ERROR, _EL_USER_WARNING, _EL_USER_NOTICE),
					 'core'     => array(_EL_CORE_ERROR, _EL_CORE_WARNING),
					 'compile'  => array(_EL_COMPILE_ERROR, _EL_COMPILE_WARNING, _EL_PARSE),
					 );

  public static $SystemErrorTypes =
    array (
					 E_ERROR           => _EL_ERROR,
					 E_WARNING         => _EL_WARNING,
					 E_PARSE           => _EL_PARSE,
					 E_NOTICE          => _EL_NOTICE,
					 E_CORE_ERROR      => _EL_CORE_ERROR,
					 E_CORE_WARNING    => _EL_CORE_WARNING,
					 E_COMPILE_ERROR   => _EL_COMPILE_ERROR,
					 E_COMPILE_WARNING => _EL_COMPILE_WARNING,
					 E_USER_ERROR      => _EL_USER_ERROR,
					 E_USER_WARNING    => _EL_USER_WARNING,
					 E_USER_NOTICE     => _EL_USER_NOTICE,
					 E_STRICT          => _EL_STRICT,
					 );

  private static $PrettyErrorTypes =
    array (
					 _EL_DEBUG           => "Debug",
					 _EL_INFO            => "Info",
					 _EL_ERROR           => "Error",
					 _EL_WARNING         => "Warning",
					 _EL_PARSE           => "Parsing Error",
					 _EL_NOTICE          => "Notice",
					 _EL_CORE_ERROR      => "Core Error",
					 _EL_CORE_WARNING    => "Core Warning",
					 _EL_COMPILE_ERROR   => "Compile Error",
					 _EL_COMPILE_WARNING => "Compile Warning",
					 _EL_USER_ERROR      => "User Error",
					 _EL_USER_WARNING    => "User Warning",
					 _EL_USER_NOTICE     => "User Notice",
					 _EL_STRICT          => "Runtime Notice"
					 );

  /**
   * Present an error type for display in messages
   * @param $pErrorType the internal EVO_ error type
   * @return string phrase
   */
  public static function PrettyErrorType($pErrorType) {
    return empty(self::$PrettyErrorTypes[$pErrorType]) ? null : self::$PrettyErrorTypes[$pErrorType];
  }

  /**
   * Classify an error type, stripping away the distinction between system, core and user
   * @param $pErrorType the internal EVO_ error type
   * @return string classification
   */
  public static function stClassifyErrorType($pErrorType) {
    return empty(self::$ClassifyErrorTypes[$pErrorType]) ? false : self::$ClassifyErrorTypes[$pErrorType];
  }
  public function classifyErrorType() {
    return empty(self::$ClassifyErrorTypes[$this->layoutType]) ? null : self::$ClassifyErrorTypes[$this->layoutType];
  }

  /**
   * Convert a system error type to an EventObject error type
   * @param $pSystemErrorType the system E_ error integer
   * @return string , the EVO_ string error type
   */
  public static function ErrorType($pSystemErrorType) {
    return empty(self::$SystemErrorTypes[$pSystemErrorType]) ? null : self::$SystemErrorTypes[$pSystemErrorType];
  }

  /**
   * @static method to convert a string of event levels to a hash of booleans
   *
   * The specific event levels correspond to php error types, @see the php function error_reporting() for
   * more details.
   *
   * The generic event levels are debug, info, notice, warning, error, critical, user, core and compile.
   *
   * Each event level in the list may be prefixed with a "=" or a "!" character.  If there is no prefix,
   * the range of message types matched is the generic level and upwards.  With the "=" character, just that
   * message type is matched.  Conversely, with the "!" character, the message type is specifically disallowed.
   *
   * "=debug" - EVO_DEBUG
   * "error" - E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_USER_ERROR
   * "user,critical" - E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE, EVO_CRITICAL
   * "=notice,debug,!core" - EVO_NOTICE, EVO_USER_NOTICE, EVO_STRICT,
   *     EVO_DEBUG, EVO_INFO, E_WARNING, E_COMPILE_WARNING, E_USER_WARNING, E_ERROR, E_COMPILE_ERROR, E_USER_ERROR, EVO_CRITICAL
   *     !core turns E_CORE_ERROR and E_CORE_WARNING off, which would have been enabled by "debug"
   * "core error, compile error, critical" - E_CORE_ERROR, E_COMPILE_ERROR, EVO_CRITICAL
   *
   * @see error_reporting()
   * @param string $pThresholds a comma separated list of event levels
   * @return hash of booleans
   */
  public static function ConvertThresholds($pThresholds) {
    $basket = EventObject::$ClassifyErrorTypes;
    foreach ($basket as $type => $class) {
      $basket[$type] = false;
    }

    $thresholds = explode(',', $pThresholds);
    foreach ($thresholds as $level) {
      $level = trim($level);
      // debug, info, notice, warning, error, critical

      if (substr($level,0,1) == '=' || substr($level,0,1) == '!') {
				$modifier = substr($level,0,1);
				$level = substr($level,1);
      }
      else
				$modifier = '';

      if (preg_match('/^(?:all|debug|info|notice|warning|error|critical|user|core|compile)$/', $level)) {
				if (!empty($modifier))
					$types = array($level);
				elseif ($level=='all') {
					$types = array_keys($basket);
				}
				else {
					$order = 'debug|info|warning|error|critical';
					$pos = strpos($order, $level);
					if ($pos!==false)
						$types = explode('|', substr($order,$pos));
					else
						$types = array($level);
				}

				foreach ($types as $type2) {
					$typegroups = empty(EventObject::$GroupErrorTypes[$type2]) ? array($type2) : EventObject::$GroupErrorTypes[$type2];
					foreach ($typegroups as $type3) {
						$basket[$type3] = empty($modifier) || $modifier=='=' ? true : false;
					}
				}
      }
      elseif (array_key_exists($basket, $level)) {
				$basket[$level] = empty($modifier) || $modifier=='=' ? true : false;
      }
      else {
				// whatever
				$basket[$level] = empty($modifier) || $modifier=='=' ? true : false;
      }
    }

    return $basket;
  }
}

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class EventChannel {
  protected $formatter;
  protected $thresholds;

  protected $holdFlag;
  protected $eventFifo;

  protected $blockPercolation;

  protected $name;

	protected $formattingInfo;

  public function __construct($pFormatter=null, $pThresholds=null, $pBlockPercolation=null, $pHoldFlag=null) {
    $this->formatter = $pFormatter;
    $this->thresholds = EventObject::ConvertThresholds($pThresholds);
    $this->eventFifo = array();
		$this->formattingInfo = array();
    $this->blockPercolation = empty($pBlockPercolation) ? false : true;
    if (isset($pHoldFlag)) $this->holdFlag = $pHoldFlag;
  }

  function __destruct() {
    $this->flushEventQueue();
  }

  public function setFormatter($obj) {
    $sav = $this->formatter;
    $this->formatter = $obj;
    return $sav;
  }
  public function getFormatter() {
    return $this->formatter;
  }

  public function getHoldFlag() {
    return $this->holdFlag;
  }
  public function setHoldFlag($flag) {
    $sav = $this->holdFlag;
    $this->holdFlag = $flag;
    return $sav;
  }

  public function getName() {
    return $this->name;
  }
  public function setName($pName) {
    $sav = $this->name;
    if (empty($sav)) $this->name = $pName;
    return $sav;
  }

	public function getFormattingInfo($keyword) {
		if ($keyword===null) return null;
		return array_key_exists($this->formattingInfo[$keyword]) ? $this->formattingInfo[$keyword] : null;
	}
	public function setFormattingInfo($keyword, $value=null) {
		$sav = array_key_exists($this->formattingInfo[$keyword]) ? $this->formattingInfo[$keyword] : null;

		if ($value===null)
			unset( $this->formattingInfo[$keyword] );
		else
			$this->formattingInfo[$keyword] = $value;

		return $sav;
	}
	public function getAllFormattingInfo() {
		return $this->formattingInfo;
	}

  public function checkType($event) {
    return $event->getType() == 'log' ? true : false;
  }

  public function passesThresholds($event, $pEffectiveImportance=null) {
    $myImportance = !empty($pEffectiveImportance) ? $pEffectiveImportance : $event->getImportance();
    return empty($this->thresholds[$myImportance]) ? false : true;
  }

  public function receiveEvent($event, $pEffectiveImportance=null) {
    if ($this->checkType($event) && $this->passesThresholds($event, $pEffectiveImportance)) {
      if ($this->holdFlag)
				$this->queueEvent($event);
      else {
				if (!empty($this->eventFifo) && count($this->eventFifo)>0) $this->flushEventQueue();
				$this->processEvent($event);
      }
    }

    return !empty($this->blockPercolation) ? false : true;
  }

  public function processEvent($event) {
    // $dt = date("Y-m-d H:i:s (T)", $event->getTimestamp());

    print $this->formatter->formatEvent($event, $this->formattingInfo);

    return $this->blockPercolation;
  }

  public function queueEvent($event) {
    array_push($this->eventFifo, $event);
  }
  public function dequeueEvent() {
    if (empty($this->eventFifo) || count($this->eventFifo)==0) return false;
    $this->processEvent(array_shift($this->eventFifo));
    return true;
  }
  public function flushEventQueue() {
    $counter = 0;
    while ($this->dequeueEvent()) {
      $counter++;
    }
    return $counter;
  }
  public function discardEventQueue() {
    $this->eventFifo = array();
  }
}

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class PrintChannel extends EventChannel {
  // an alias
}

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class NullChannel extends EventChannel {
  public function __construct($pThresholds=null, $pBlockPercolation=null) {
    parent::__construct(new EventFormatter(), $pThresholds, $pBlockPercolation);
  }

  public function processEvent($event) {
    return $this->blockPercolation;
  }
}

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class ArrayChannel extends EventChannel {
  public function __construct($pFormatter=null, $pThresholds=null, $pBlockPercolation=null) {
    parent::__construct($pFormatter, $pThresholds, $pBlockPercolation);
    $this->holdFlag = true;
  }
  function __destruct() {
    $this->discardEventQueue();
  }

  public function getHoldFlag() {
    return true;
  }
  public function setHoldFlag($flag) {
    return true;
  }
}

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class FileChannel extends EventChannel {
  private $filename;
  private $io;

  public function __construct($pFilename, $pFormatter=null, $pThresholds=null, $pBlockPercolation=null, $pHoldFlag=null) {
    parent::__construct($pFormatter, $pThresholds, $pBlockPercolation, $pHoldFlag);
    $this->filename = $pFilename;
    $this->io = fopen($pFilename, "a");	// returns false if it fails, and issues E_WARNING message
  }

  public function __destruct() {
    if (!empty($this->io)) fclose($this->io);
  }

  public function processEvent($event) {
    // $dt = date("Y-m-d H:i:s (T)", $event->getTimestamp());

    if (!empty($this->io)) fwrite($this->io, $this->formatter->formatEvent($event, $this->formattingInfo));

    return $this->blockPercolation;
  }
}

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class EventFormatter {
  public function formatEvent($event, $info=null) {
    $myErrorClass = $event->classifyErrorType();

    $myFilename = $event->getFilename();
    $myLinenum = $event->getLinenum();

    $string = $this->formatMessage($myErrorClass,
																	 EventObject::PrettyErrorType($event->getLayoutType()),
																	 $event->getMessage(),
																	 $myFilename,
																	 $myLinenum);

    if ($myErrorClass == 'error') {
      $string .= "<br/>\nStack Backtrace\n<pre>\n" .
				self::FormatBacktrace($event->getContext()) .
				"</pre>\n"
				;
    }

    return $string;
  }

  public function formatMessage($pCSSClass, $pMessageType, $pMessage, $pFilename, $pLinenum) {
    $string = (!empty($pCSSClass) ? "<span class='log_$pCSSClass'>" : '') .
      "<b>$pMessageType</b>: $pMessage" .
      (!empty($pFilename) ? " in <b>$pFilename</b>" . (!empty($pLinenum) ? " on line <b>$pLinenum</b>" : "") : "") .
      (!empty($pCSSClass) ? "</span>" : '') .
      "<br/>\n";

    return $string;
  }

  public static function FormatBacktrace($trace) {
    $string = '';
    for ($i=0; $i<count($trace); $i++) {
      $item = $trace[$i];
      // #0 eval() called at [/tmp/include.php:5]
      // #1 a() called at [/tmp/include.php:17]
      // #2 include(/tmp/include.php) called at [/tmp/test.php:3]

      $string .= "   #$i ".(!empty($item['class']) ? $item['class'] . $item['type'] : '') . $item['function'] . '(';
      for ($j=0, $args = $item['args']; $j < count($args); $j++) {
				if (is_null($args[$j])) $val = 'null';
				elseif (is_bool($args[$j])) $val = $args[$j] ? 'true' : 'false';
				elseif (is_numeric($args[$j])) $val = $args[$j];
				else $val = "'" . $args[$j] . "'";

				$string .= ($j>0 ? ',' : '') . $val;
      }

      $string .= ') called at [' . (empty($item['file']) ? "" : $item['file']) . ':' . (empty($item['line']) ? "" : $item['line']) . "]\n";
    }
    return $string;
  }
}

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class HTMLFormatter extends EventFormatter {
  // alias
}

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class SyslogFormatter extends EventFormatter {
  public function formatEvent($event, $info=null) {
    $dt = date("Y-m-d H:i:s (T)", $event->getTimestamp());

    $myFilename = $event->getFilename();
    $myLinenum = $event->getLinenum();

    $string = "$dt ".EventObject::PrettyErrorType($event->getLayoutType()).": "
			. $event->getMessage()
			. (!empty($myFilename) ? " in $myFilename". (!empty($myLinenum) ? " on line $myLinenum" : "") : "")
			. "\n";

    if ($event->classifyErrorType() == 'error') {
      $string .= "   Stack Backtrace\n" .
				self::FormatBacktrace($event->getContext()) .
				"\n"
				;
    }

    return $string;
  }
}

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class HTMLCommentsFormatter extends EventFormatter {
  public function formatEvent($event, $info=null) {
    $myFilename = $event->getFilename();
    $myLinenum = $event->getLinenum();

    $string = "<!-- ".EventObject::PrettyErrorType($event->getLayoutType()).": ".
      $event->getMessage().
      (!empty($myFilename) ? " in $myFilename" . (!empty($myLinenum) ? " on line $myLinenum" : "") : "");

    if ($event->classifyErrorType() == 'error') {
      $string .= "\nStack Backtrace\n" .
				self::FormatBacktrace($event->getContext()) .
				"\n"
				;
    }

    $string .= " -->\n";

    return $string;
  }
}

/**
 * @package    WiFiDogAuthServer
 * @subpackage Eventlogging
 * @author     Rob Janes <janes.rob@gmail.com>
 * @copyright  2005-2006 Rob Janes
 */
class HTMLTableFormatter extends EventFormatter {
  public function formatMessage($pCSSClass, $pMessageType, $pMessage, $pFilename, $pLinenum) {
    $pCSSClass = empty($pCSSClass) ? '' : "class='$pCSSClass'";
    $string = "<tr>" .
      "<td $pCSSClass>$pMessageType</td><td $pCSSClass>$pMessage</td>" .
      (!empty($pFilename) ? "<td $pCSSClass>$pFilename</td>" .
       (!empty($pLinenum) ? "<td $pCSSClass>$pLinenum</td>" : "") : "") .
      "</tr>\n";

    return $string;
  }
}


function elBomb($pMessage=null) {
  if (func_num_args() > 0) EventLogging::stBomb($pMessage);
  else EventLogging::stBomb();
}

function elLogMessage($errmsg, $errno=EventObject::EVO_USER_NOTICE) {
  EventLogging::stMessage($errmsg, $errno);
}
function elLogError($errmsg) {
  EventLogging::stMessage($errmsg, EventObject::EVO_USER_ERROR);
}
function elLogWarning($errmsg) {
  EventLogging::stMessage($errmsg, EventObject::EVO_USER_WARNING);
}
function elLogNotice($errmsg) {
  EventLogging::stMessage($errmsg, EventObject::EVO_USER_NOTICE);
}
function elLogDebug($errmsg) {
  EventLogging::stMessage($errmsg, EventObject::EVO_DEBUG);
}
function elLogInfo($errmsg) {
  EventLogging::stMessage($errmsg, EventObject::EVO_INFO);
}

/*
 * Local variables:
 * tab-width: 2
 * c-basic-offset: 2
 * c-hanging-comment-ender-p: nil
 * End:
 */


